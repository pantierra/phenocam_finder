<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Evaluation Results Map</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .popup-content {
            font-family: Arial, sans-serif;
            max-width: 400px;
        }

        .site-header {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .site-description {
            margin-bottom: 12px;
            color: #555;
            font-style: italic;
        }

        .seasons-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .season-block {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            background-color: #f9f9f9;
        }

        .season-header {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 8px;
            color: #2980b9;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            font-size: 12px;
            margin-top; 10px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
        }

        .metric-label {
            color: #666;
        }

        .metric-value {
            font-weight: bold;
            color: #2c3e50;
        }

        .ndvi-expandable {
            margin-top: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .ndvi-toggle {
            background-color: #e8f5e9;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            color: #2e7d32;
        }

        .ndvi-toggle:hover {
            background-color: #c8e6c9;
        }

        .ndvi-toggle-icon {
            transition: transform 0.3s;
        }

        .ndvi-toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .ndvi-time-series {
            max-height: 200px;
            overflow-y: auto;
            display: none;
            background-color: #f9f9f9;
        }

        .ndvi-time-series.show {
            display: block;
        }

        .ndvi-observation {
            padding: 4px 12px;
            border-bottom: 1px solid #eee;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .ndvi-observation:last-child {
            border-bottom: none;
        }

        .ndvi-date {
            color: #666;
        }

        .ndvi-value {
            font-weight: bold;
            color: #2e7d32;
        }

        /* Style for outliers (implausible NDVI) and null values */
        .ndvi-observation.cloudy {
            background-color: #f5f5f5;
            opacity: 0.7;
        }

        .ndvi-observation.cloudy .ndvi-value {
            color: #999;
            font-weight: normal;
            font-style: italic;
        }

        .sidebar {
            position: fixed;
            top: 0;
            right: -500px;
            width: 500px;
            height: 100vh;
            background-color: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .sidebar.open {
            right: 0;
        }

        .sidebar-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .sidebar-close:hover {
            background: #c82333;
        }

        #sidebar-content {
            margin-top: 40px;
        }

        .filter-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #2980b9;
            border-radius: 8px;
            padding: 12px 18px;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            font-family: Arial, sans-serif;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        .filter-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
            font-size: 15px;
        }

        .filter-toggle input[type="checkbox"] {
            transform: scale(1.3);
            cursor: pointer;
        }

        .filter-toggle:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }

    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Filter Toggle -->
    <div class="filter-toggle">
        <label>
            <input type="checkbox" id="highQualityFilter" onchange="toggleHighQualityFilter()">
            Show selected sites
        </label>
    </div>

    <!-- Sidebar -->
    <div id="sidebar" class="sidebar">
        <button class="sidebar-close" onclick="closeSidebar()">&times;</button>
        <div id="sidebar-content"></div>
    </div>

</body>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <script>
        // Initialize the map
        const map = L.map('map').setView([36.94, -2.0332], 10);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Function to load GeoJSON data
        async function loadGeoJSONData() {
            try {
                const response = await fetch(`all_sites.geojson?t=${Date.now()}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const geojsonData = await response.json();
                return geojsonData;
            } catch (error) {
                console.error('Error loading GeoJSON data:', error);
                alert('Error loading site data. Please make sure all_sites.geojson is in the same directory as this HTML file.');
                return null;
            }
        }

        // Function to load selected sites GeoJSON data
        async function loadSelectedSitesData() {
            // First try to load pre-generated filtered GeoJSON
            try {
                const response = await fetch('selected_sites.geojson');
                if (response.ok) {
                    const filteredGeojson = await response.json();
                    console.log('Loaded pre-filtered GeoJSON');
                    return { type: 'filtered_geojson', data: filteredGeojson };
                }
            } catch (error) {
                console.log('Pre-filtered GeoJSON not found, falling back to config.yaml');
            }

            // Fallback to parsing config.yaml
            try {
                const response = await fetch('config.yaml');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const yamlText = await response.text();

                // Simple YAML parser for the config structure
                const config = {};
                const lines = yamlText.split('\n');
                let currentSite = null;

                for (const line of lines) {
                    // Skip comments and empty lines
                    if (line.trim().startsWith('#') || line.trim() === '') continue;

                    // Check if it's a site line (no leading dash)
                    if (line.match(/^  \w+:$/)) {
                        currentSite = line.trim().replace(':', '');
                        config[currentSite] = [];
                    }
                    // Check if it's a year line (with leading dash)
                    else if (line.match(/^    - \d+$/)) {
                        const year = line.trim().replace('-', '').trim();
                        if (currentSite) {
                            config[currentSite].push(year);
                        }
                    }
                }

                console.log('Loaded config.yaml:', config);
                // Debug log for vindeln2 specifically
                if (config['vindeln2']) {
                    console.log('vindeln2 configured years:', config['vindeln2']);
                }
                return { type: 'config', data: config };
            } catch (error) {
                console.error('Error loading selected sites data:', error);
                // Return null silently if neither file exists
                return null;
            }
        }

        // Function to create popup content
        function createPopupContent(properties) {
            const {sitename, vegetation_type, description, seasons} = properties;

            let seasonsHtml = '';
            // Sort seasons by year in descending order
            const sortedSeasons = Object.entries(seasons || {}).sort((a, b) => b[0] - a[0]);
            sortedSeasons.forEach(([year, data]) => {
                seasonsHtml += `
                    <div class="season-block">
                        <div class="season-header">${year} Season</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">${data.season_start_date} to ${data.season_end_date} (${data.season_length_days} days)</div>
                        <div class="metrics-grid">
                            <div class="metric">
                                <span class="metric-label">S2 Scenes:</span>
                                <span class="metric-value">${data.sentinel2_scenes}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">S2 Cloud %:</span>
                                <span class="metric-value">${data.s2_cloud_cover_mean}%</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">S3 Scenes:</span>
                                <span class="metric-value">${data.sentinel3_scenes}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label"></span>
                                <span class="metric-value"></span>
                            </div>

                            ${data.ndvi_observations > 0 ? `
                            <div class="metric">
                                <span class="metric-label">NDVI Mean:</span>
                                <span class="metric-value" style="color: #2e7d32; font-weight: bold;">${data.ndvi_mean.toFixed(3)}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">NDVI Range:</span>
                                <span class="metric-value" style="color: #2e7d32;">${data.ndvi_min.toFixed(3)} - ${data.ndvi_max.toFixed(3)}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label" title="Maximum gap between clear S2 scenes used for NDVI">Max S2 Gap (clear):</span>
                                <span class="metric-value">${data.ndvi_max_s2_gap_days} days</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label" title="Maximum gap between all available S2 scenes">Max S2 Gap (all):</span>
                                <span class="metric-value">${data.max_s2_gap_days} days</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label" title="Number of gaps >3 days between clear S2 scenes used for NDVI">S2 Gap Count (clear):</span>
                                <span class="metric-value">${data.ndvi_s2_gap_count}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label" title="Number of gaps >3 days between all S2 scenes">S2 Gap Count (all):</span>
                                <span class="metric-value">${data.s2_gap_count}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label" title="Weighted gap score for clear S2 scenes used for NDVI">S2 Weighted Gap (clear):</span>
                                <span class="metric-value">${data.ndvi_s2_weighted_gap_score}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label" title="Weighted gap score for all S2 scenes">S2 Weighted Gap (all):</span>
                                <span class="metric-value">${data.s2_weighted_gap_score}</span>
                            </div>
                            ` : ''}
                        </div>
                        ${data.ndvi_observations > 0 && data.ndvi_time_series !== undefined && data.ndvi_time_series.length > 0 ? `
                        <div class="ndvi-expandable">
                            <div class="ndvi-toggle" onclick="toggleNDVITimeSeries(event)">
                                <span>NDVI Time Series (${data.ndvi_time_series ? data.ndvi_time_series.filter(obs => obs.ndvi !== null && !obs.outlier).length : data.ndvi_observations} of ${data.ndvi_time_series ? data.ndvi_time_series.length : 'N/A'} dates)</span>
                                <span class="ndvi-toggle-icon">â–¶</span>
                            </div>
                            <div class="ndvi-time-series">
                                ${data.ndvi_time_series.map(obs => `
                                    <div class="ndvi-observation ${obs.ndvi === null || obs.outlier ? 'cloudy' : ''}">
                                        <span class="ndvi-date">${obs.date}</span>
                                        <span class="ndvi-value">${obs.ndvi !== null ? obs.ndvi.toFixed(4) : 'N/A'}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                `;
            });

            return `
                <div class="popup-content">
                    <div class="site-header">${sitename.toUpperCase()}${vegetation_type ? ` - ${vegetation_type}` : ''}</div>
                    <div style="margin-bottom: 8px;">
                        <a href="https://phenocam.nau.edu/webcam/sites/${sitename}" target="_blank" style="color: #2980b9; text-decoration: none; font-size: 13px;">
                            ðŸ”— View on PhenoCam
                        </a>
                    </div>
                    <div class="site-description">${description}</div>
                    <div class="seasons-container">
                        ${seasonsHtml}
                    </div>
                </div>
            `;
        }

        // Function to get marker style based on vegetation type
        function getMarkerStyle(properties, isSelected = false) {
            const vegetation_type = properties.vegetation_type || '';

            // Define colors for vegetation types
            const vegColors = {
                'Grassland': '#90EE90',        // Light green
                'Agriculture': '#FFD700',       // Gold
                'Deciduous Broadleaf': '#228B22', // Forest green
                'Evergreen Needleleaf': '#006400', // Dark green
                'Shrubland': '#D2691E',        // Chocolate brown
                'Wetland': '#4682B4',          // Steel blue
                'Tundra': '#B0C4DE'            // Light steel blue
            };

            let fillColor = vegColors[vegetation_type] || '#808080'; // Default gray

            return {
                radius: 10,
                fillColor: fillColor,
                color: isSelected ? '#FF6600' : '#000',  // Orange border when selected
                weight: isSelected ? 3 : 2,              // Thicker border when selected
                opacity: 1,
                fillOpacity: 0.85
            };
        }

        // Global variables
        let geoJsonLayer = null;
        let originalGeoJsonData = null;
        let selectedSitesData = null;
        let selectedMarker = null;  // Track currently selected marker

        // Initialize map with data
        async function initializeMap() {
            const geojsonData = await loadGeoJSONData();

            if (!geojsonData) {
                return; // Error already handled in loadGeoJSONData
            }

            // Store original data for filtering
            originalGeoJsonData = geojsonData;

            // Load selected sites data
            selectedSitesData = await loadSelectedSitesData();

            // Create initial layer
            createGeoJsonLayer(geojsonData);

            // Fit map to show all features
            fitMapToFeatures(geojsonData);
        }

        // Function to create GeoJSON layer
        function createGeoJsonLayer(geojsonData) {
            // Remove existing layer if it exists
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }

            // Add GeoJSON layer to map
            geoJsonLayer = L.geoJSON(geojsonData, {
                pointToLayer: function(feature, latlng) {
                    return L.circleMarker(latlng, getMarkerStyle(feature.properties));
                },
                onEachFeature: function(feature, layer) {
                    layer.on('click', function(e) {
                        // Reset previous selected marker
                        if (selectedMarker) {
                            selectedMarker.setStyle(getMarkerStyle(selectedMarker.feature.properties, false));
                        }

                        // Set new selected marker
                        selectedMarker = layer;
                        layer.setStyle(getMarkerStyle(feature.properties, true));

                        openSidebar(feature.properties);
                    });
                }
            }).addTo(map);
        }

        // Function to fit map to features
        function fitMapToFeatures(geojsonData) {
            const bounds = L.latLngBounds();
            geojsonData.features.forEach(feature => {
                if (feature.geometry.type === 'Point') {
                    bounds.extend([feature.geometry.coordinates[1], feature.geometry.coordinates[0]]);
                }
            });

            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }

        // Track currently open sidebar site
        let currentSidebarSite = null;

        // Function to open sidebar
        function openSidebar(properties) {
            currentSidebarSite = properties.sitename;
            const sidebarContent = document.getElementById('sidebar-content');
            sidebarContent.innerHTML = createPopupContent(properties);
            document.getElementById('sidebar').classList.add('open');
        }

        // Function to close sidebar
        function closeSidebar() {
            currentSidebarSite = null;
            document.getElementById('sidebar').classList.remove('open');

            // Reset selected marker style
            if (selectedMarker) {
                selectedMarker.setStyle(getMarkerStyle(selectedMarker.feature.properties, false));
                selectedMarker = null;
            }
        }

        // Function to toggle high quality filter
        function toggleHighQualityFilter() {
            const checkbox = document.getElementById('highQualityFilter');
            const isChecked = checkbox.checked;

            if (!originalGeoJsonData) {
                return;
            }

            let dataToShow;

            if (isChecked && selectedSitesData) {
                // Check if we have pre-filtered GeoJSON or need to filter manually
                if (selectedSitesData.type === 'filtered_geojson') {
                    // Use pre-filtered GeoJSON directly
                    dataToShow = selectedSitesData.data;
                } else if (selectedSitesData.type === 'config') {
                    // Filter sites and seasons based on config.yaml
                    const configData = selectedSitesData.data;
                    dataToShow = {
                        type: "FeatureCollection",
                        features: originalGeoJsonData.features.filter(feature => {
                            const sitename = feature.properties.sitename;
                            // Check if site is in the config
                            if (configData[sitename]) {
                                // Check if this site has any of the selected years
                                const selectedYears = configData[sitename];
                                // Debug log for vindeln2
                                if (sitename === 'vindeln2') {
                                    console.log('vindeln2 filtering - Selected years:', selectedYears);
                                    console.log('vindeln2 filtering - Available seasons:', Object.keys(feature.properties.seasons || {}));
                                }
                                const hasSelectedSeasons = Object.keys(feature.properties.seasons || {})
                                    .some(year => selectedYears.includes(year));
                                return hasSelectedSeasons;
                            }
                            return false;
                        }).map(feature => {
                            // Map the filtered features with updated seasons
                            const sitename = feature.properties.sitename;
                            const selectedYears = configData[sitename];
                            const filteredSeasons = {};

                            for (const [year, seasonData] of Object.entries(feature.properties.seasons || {})) {
                                if (selectedYears.includes(year)) {
                                    filteredSeasons[year] = seasonData;
                                }
                            }

                            // Debug log for vindeln2
                            if (sitename === 'vindeln2') {
                                console.log('vindeln2 final filtered seasons:', Object.keys(filteredSeasons));
                            }

                            return {
                                ...feature,
                                properties: {
                                    ...feature.properties,
                                    seasons: filteredSeasons
                                }
                            };
                        })
                    };
                } else {
                    // Fallback to showing all sites if data structure is unexpected
                    dataToShow = originalGeoJsonData;
                }
            } else {
                // Show all sites
                dataToShow = originalGeoJsonData;
            }

            // Store current selection before recreating layer
            const wasSelectedSite = currentSidebarSite;
            selectedMarker = null;

            // Update the map with the appropriate data
            createGeoJsonLayer(dataToShow);

            // Fit map to the new data
            fitMapToFeatures(dataToShow);

            // Update sidebar if currently open and restore selection
            if (wasSelectedSite) {
                const feature = dataToShow.features.find(f => f.properties.sitename === wasSelectedSite);
                if (feature) {
                    // Site is still in filtered data, update sidebar
                    const sidebarContent = document.getElementById('sidebar-content');
                    sidebarContent.innerHTML = createPopupContent(feature.properties);

                    // Restore the orange border selection on the new layer
                    geoJsonLayer.eachLayer(function(layer) {
                        if (layer.feature && layer.feature.properties.sitename === wasSelectedSite) {
                            selectedMarker = layer;
                            layer.setStyle(getMarkerStyle(layer.feature.properties, true));
                        }
                    });
                } else {
                    // Site was filtered out, close sidebar
                    closeSidebar();
                }
            }
        }

        // Function to toggle NDVI time series visibility
        function toggleNDVITimeSeries(event) {
            event.stopPropagation();
            const toggle = event.currentTarget;
            const icon = toggle.querySelector('.ndvi-toggle-icon');
            const timeSeries = toggle.nextElementSibling;

            icon.classList.toggle('expanded');
            timeSeries.classList.toggle('show');
        }

        // Load the data and initialize the map
        initializeMap();
    </script>
</body>
</html>
```
